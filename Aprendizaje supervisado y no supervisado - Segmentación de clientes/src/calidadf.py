# -*- coding: utf-8 -*-
"""calidadf.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p9HYsa9t6Gyk9tcgSQf82MMuu1G_IEFX
"""

import pandas as pd
import numpy as np

def calidad_datos(datos):
    # âœ… Verifica si el DataFrame estÃ¡ vacÃ­o antes de hacer cÃ¡lculos
    if datos.empty:
        return "El DataFrame estÃ¡ vacÃ­o."

    # ðŸ“Œ Genera un resumen de estadÃ­sticas generales
    # `datetime_is_numeric=True` permite analizar fechas como valores numÃ©ricos
    resumen = datos.describe(include='all').T

    # ðŸ“Œ Calcula el rango intercuartil (IQR) para detectar valores atÃ­picos
    resumen['IQR'] = resumen['75%'] - resumen['25%']
    resumen['lim_inf'] = resumen['25%'] - 1.5 * resumen['IQR']  # LÃ­mite inferior
    resumen['lim_sup'] = resumen['75%'] + 1.5 * resumen['IQR']  # LÃ­mite superior

    # ðŸ“Œ Cuenta los valores atÃ­picos solo en columnas numÃ©ricas
    resumen['atipicos'] = datos.select_dtypes(include=[np.number]).apply(
        lambda x: ((x < resumen.loc[x.name, 'lim_inf']) |
                   (x > resumen.loc[x.name, 'lim_sup'])).sum()
        if x.name in resumen.index else 0  # Solo calcular si la columna estÃ¡ en `resumen`
    )

    # ðŸ“Œ Diccionario con mÃ©tricas de calidad de datos
    info_calidad = {
        'tipo': datos.dtypes,  # Tipo de datos de cada columna
        'nan': datos.isna().sum(),  # Conteo de valores nulos
        'porcentaje_nan': datos.isna().mean() * 100,  # % de valores nulos
        'ceros': datos.eq(0).sum(),  # Conteo de ceros
        'porcentaje_ceros': datos.eq(0).mean() * 100,  # % de valores ceros
        'valores_unicos': datos.nunique(),  # Cantidad de valores Ãºnicos
        'porcentaje_unicos': datos.nunique() / len(datos) * 100,  # % de valores Ãºnicos
    }

    # ðŸ“Œ Calcula la moda de cada columna de manera segura
    try:
        info_calidad['moda'] = datos.mode().iloc[0]  # Primera moda
    except:
        info_calidad['moda'] = np.nan  # Si hay error (columna vacÃ­a), asigna NaN

    # ðŸ“Œ AnÃ¡lisis de datos numÃ©ricos adicionales
    datos_numericos = datos.select_dtypes(include=[np.number])  # Filtra solo numÃ©ricos
    if not datos_numericos.empty:
        info_calidad['desviacion_std'] = datos_numericos.std()  # DesviaciÃ³n estÃ¡ndar
        info_calidad['coef_variacion'] = (datos_numericos.std() / datos_numericos.mean()).replace([np.inf, -np.inf], np.nan)  # Coeficiente de variaciÃ³n (evita divisiÃ³n por 0)
        info_calidad['skewness'] = datos_numericos.skew()  # AsimetrÃ­a (skewness)
        info_calidad['kurtosis'] = datos_numericos.kurtosis()  # Curtosis

    # ðŸ“Œ Convertir el diccionario en DataFrame y unir con `resumen`
    df_calidad = pd.DataFrame(info_calidad).join(resumen, how='left')

    # ðŸ“Œ Ordenar los datos por tipo, dejando los NaN al final
    return df_calidad.sort_values('tipo', na_position='last')